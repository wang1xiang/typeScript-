<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
  <script src="../js/类/class.js"></script>
  <script>
    // es的类
    // function Person () {
    //   this.name = 'zhangsan'
    //   this.age = 12
    // }
    // let p = new Person()
    // p.name
    
    // 构造函数和原型链里面增加方法
    // function Person() {
    //   this.name = 'zhangsan'
    //   this.age = 12
    //   this.run = function () {
    //     alert(this.name + '运动')
    //   }
    // }
    // Person.prototype.sex = '男'
    // Person.prototype.work = function() {
    //   alert(this.name + '在工作')
    // }
    // let p = new Person()
    // p.run()
    // p.work()

    // es5继承 原型链加对象冒充的组合继承模式
    // function Web() {
    //   Person.call(this)
    // }
    // let w = new Web()
    // w.run() // 对象冒充可以继承构造函数里的属性和方法
    // w.work() // 不能继承原型链上的属性和方法

    // 原型链实现继承 可以继承构造函数和原型链上的方法和属性
    // 问题：实例化子类的时候没法给父类传参
    // function Web() {
    // }
    // Web.prototype = new Person()
    // let w = new Web()
    // w.run()
    // w.work() 

    // 原型链和构造函数的组合继承
    // function Person1(name, age) {
    //   this.name = name
    //   this.age = age
    //   this.run = function () {
    //     alert(this.name + '运动')
    //   }
    // }
    // Person1.prototype.sex = '男'
    // Person1.prototype.work = function() {
    //   alert(this.name + '在工作')
    // }

    // function Web (name, age) {
    //   Person1.call(this, name, age)
    // }
    // // Web.prototype = new Person1()
    // Web.prototype = Person.prototype
    // let w = new Web('zhaosi', 20)
    // w.run()
    // w.work()
    // function Person() {
    //   this.run = function () {
    //   }
    // }
    // Person.name = 'hhh' // 静态属性
    // Person.run1 = function() { // 静态方法
    // }
    // let p = new Person()
    // p.run1()
  </script>
</head>
<body>
  
</body>
</html>